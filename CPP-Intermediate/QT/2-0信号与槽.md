## 信号与槽函数的介绍
##### 信号与槽机制
用来在组件和组件之间，组件和窗口之间通信的一种机制          
**一个类如果要使用信号以及槽函数，那么该类的定义就必须加上 Q_OBJECT 宏定义**。          
Q_OBJECT: Qt中称为元对象系统，作用是支持信号与槽这种机制          

##### 信号
Qt中给每个组件都定义了信号，每个信号都有它特定的触发条件          
Qt中的信号，本质上是个函数。但是有点特殊，**信号只有声明，没有源代码**          

##### 槽函数
当某个信号被触发的时候，跟这个信号对应的槽函数就会被自动调用执行          

## 如何关联信号与槽函数
##### 方法1：
借助qt设计师，在组件上右键转到槽函数          
**头文件会自动生成槽函数的声明**，**对应的源文件生成槽函数的空实现**          
```
private slots:
	void on_对象名_信号名();
```
##### 方法2：
调用 connect( ) 函数手动关联信号与槽函数
connect( ) 函数介绍：
```c++
[static] 
QMetaObject::Connection QObject::connect(
	const QObject *sender,       //信号的发送者，指针
	const char *signal,          //发送的信号
	const QObject *receiver,     //信号的接收者
	const char *method,          //需要调用的槽函数
	Qt::ConnectionType type = Qt::AutoConnection
)
```

像自定义的组件，不是直接在ui设计师中拖拽过去的，没办法右键转到槽，必须手动关联信号与槽函数，手动关联一般分为如下步骤          
1. 在头文件中添加槽函数的声明          
2. 在源文件中添加槽函数的实现          
3. 关联信号与槽          
```c++
app.h中
private slots:
	void  on_pushButton_clicked();   //这是Qt默认生成槽函数的格式
	void  on_mybutton_clicked();     //自定义槽函数完全可以根据自己的需求来编写槽函数
```
在编写槽函数时要注意，**自定义的槽函数可以根据自己的需求来命名**。          
```c++
app.cpp中

void app::on_mybutton_clicked(){
	statements;
}
```
信号与槽的关联，前提是组件已被创建。因此 connect 函数，要放在创建组件后。          
```c++
connect(mylabel, SIGNAL(clicked()), this, SLOT(on_mybutton_clicked()));
```
必须要注意：如果**信号或槽函数有参数，那么只需要写参数类型，不能写参数名**。
```c++
connect(mylabel, SIGNAL(clicked(bool)), this, SLOT(on_mybutton_clicked(bool)));
```
**致命问题：如果是通过UI界面创建的组件，使用信号与槽函数时，只需要写on_xxx_signal，无需再次使用connect进行手动关联，否则会触发两次槽函数.**

## 信号与槽须知
1. 一个类如果要使用信号以及槽函数，那么该类的定义中必须加上 Q_OBJECT 宏定义          
2. 同一个槽函数，可以被不同对象的信号关联          
3. 同一个信号，可以关联不同的槽函数          
    槽函数的调用顺序与关联顺序一致，先关联的先调用          
4. 信号带参数，槽函数可以带参数，也可以不带参数          
    区别：槽函数带参数，参数类型，参数个数必须跟信号保持一致，表示槽函数接收信号传递过来的参数          
    槽函数不带参数，表示不接受信号传递过来的参数          
5. connect( ) 中信号与槽函数的参数只需要写明参数类型即可，不需要参数名          

##### 获取信号的发送者
当多个组件对象共用一个槽函数的时候，要想知道是哪个组件触发的信号，此时就要获取信号的发送者。          
`QObject *sender() const   返回一个指向信号发送者的指针`          
举例如下：          
```c++
void MainWindow::any_clicked(){
	QPushButton *p = qobject_cast<QPushButton *>(sender());
	if(p == ui->button1){
		statement1;
	}else if(p == ui->button2){
		statement2;
	}
}

说明：sender() 获取信号发送者的函数
但是 sender() 的返回值是一个 QObject 类型的值
QObject 是所有组件的祖先(父类),父类的指针可以指向子类，但是子类的指针不能指向父类(要强转)
因此要使用 qobject_cast(QObject *object) 模板函数进行转换
```


## 日后补充
### 观察者设计模式
Qt的信号与槽机制从根本上讲就是观察者设计模式的一种体现和一种设计方案。          
槽函数对应的就是观察者，信号对应的就是被观察者。          
一个观察者可以观察多个被观察的对象，对应到信号与槽中就是一个槽函数可以对应多个信号          

#### 耦合度
- 模块与模块之间信息或者参数的依赖程度          
- 一般而言，低耦合度对应高内聚，反之亦然。低耦合性是良好的程序特性，低耦合性程序可读性、可维护性比较好          


### 信号与槽的特性
Qt信号槽机制，是Qt的核心机制，它是Qt定义的一种对象间的通讯机制，且独立于C/C++标准          

信号(signals): 当某个类对象发生内部改变时，发射“信号”随后与之关联的“槽函数”被立刻执行（如何类内正常函数调用），“信号槽”机制完全独立于任何GUI事件循环机制          
-  信号可以链接普通函数          
-  如果存在一个信号对应多个槽函数，则槽函数调用顺序 与 connect链接顺序 相同          

槽函数(slots): 等同于类普通成员函数。          
-  信号槽数量：单信号可以对应多个槽函数，单个槽函数也可以对应多个信号，互为一对多，多对一的关系。          

**信号槽链接(connect): 注册信号与槽函数对其进行绑定，实现存储与调度。**          
