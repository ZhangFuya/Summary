### 指针就是地址

说白了指针不就是一个变量吗。别的变量里边存的是整型，这看着也简单用着也及其简便的是变量。那我往变量里存一个地址，变量就不是变量了？？？
因此，在初学指针阶段，你就把指针理解成一个地址。指针里的地址对应内存中的某一个区域，因此指针就和内存关联起来了嘛。
指针和内存关联起来了。那内存里又是什么呢？？？毫无疑问内存里存放的是数据，这个数据既可以表示一个程序(程序在内存中运行，内存自然要为程序开辟一块空间)，又可以表示一个区域。既可以指向程序内，又可以执行程序外。既可以指向所在程序中的某一结构，如某个数组，某个结构体，某个函数之类的。又可以指向所在程序某一个变量，如某个 int 类型的变量，某个 char 类型的变量等等等等。
概括来说，指针就是指向任意区域的箭头。

### 指针的声明和初始化
**指针的声明要使用间接寻址运算符 *  指针的初始化要用取址运算符 &**
`int * ptr = `











## 智能指针         
智能指针其实是将 new/delete 做了一层封装，对外提供接口，让开发者更方便的去做内存管理。          
智能指针的优点：方便进行动态内存管理，减少程序出现Bug的概率。(其实就是帮你进行 delete 操作，保证忘记 delete 或者有多个指针指向同一个内存地址而不方便释放的时候，保证程序不会出现内存泄漏)            
智能指针一共有三个： shared_ptr(共享指针) 、unique_ptr(独占指针) 、 weak_ptr(配合 shared_ptr 使用)            

### shared_ptr                 
share_ptr 共享智能指针， 所谓共享是指允许多个指针指向同一个内存块，同时指向该内存块的指针也具有读写和销毁的权限。                

#### shared_ptr的初始化           
share_ptr 的初始化方式不止一种，但建议使用 make_shared 进行初始化            
`shared_ptr<int> ptr = make_shared<int>(10);`           
`shared_ptr<int> ptr (make_shared<int>(123));`          

#### shared_ptr的原理           
shared_ptr的实现原理是，每个shared_ptr 指针变量都会维护一个指向自身指向(的那个内存空间)的引用计数器，并随时同步更新，以达到与其他 shared_ptr 同步的目的。            
就是说 —— shared_ptr 有一个引用计数器，增加删减随时计数。            
```c++ 
shared_ptr 中的维护的计数器是同步更新的（本段中的指针均为 shared_ptr 类型）。               
p2 = p1;  p3 = p1;  p4 = p1;                 
有四个指针均指向p1指向的内存块。那么 shared_ptr 中的计数器是 4 这很好理解。因为计数器在共享指针中是一个地址，所以共享指针的增删，所有指针内的计数器值都会发生变化。             
1. 创建 p1 的时候，p1内的引用计数器是 1               
2. 创建 p2， 引用计数器加1，因此 p1 和 p2 中引用计数器的值都是 2              
3. 创建 p3， p1、p2、p3中的引用计数器值都是 3                 
4. 创建 p4， p1、p2、p3、p4中的引用计数器值都是 4            
5. 删除 p2， p1、p3、p4中的引用计数器值都减 1 变为 3             
```
**共享指针 引用计数器  的值一定是随着共享指针的增删而同步增减的**                
注意：共享指针作为参数(实参)传递时，在函数生命周期内，函数也有操作该内存的权限，引用计数器随参数的周期增减              

#### shared_ptr的常用操作               
-  use_count()     --     shared_ptr的引用次数(shared_ptr中引用计数器的值)                 
-  unique()     --     shared_ptr是否是独占其指向的内存地址(是否只有一个引用)                 
-  reset()    --    重置共享指针的指向           
-  get()    --    获得指针的地址     
-  swap()

#### shared_ptr的删除器                 
智能指针的销毁，由系统进行判断。但是相在智能指针销毁前进行一些操作(类似于析构函数)就要使用智能指针的另一种声明方式 `shared_ptr<int> p (new int(10), func);`。              
func就是智能指针在销毁前要执行的操作，其参数与 p 类型相同。                    
```c++
void func(int* p){          
	cout << "智能指针销毁前要执行的操作" << endl;            
	delete p;  //销毁智能指针          
}            
```

### unique_ptr             
独占指针，可以想象成程序里面的锁             
与shared_ptr不同的是：shared_ptr允许有多个 shared_ptr 指向同一个内存空间，并且这些 shared_ptr 变量对同一内存空间都有操作权限，且多个shared_ptr之间共享一个引用计数器。              
unique_ptr是独占式的，同一时间相同内存空间只允许一个 unique_ptr 指向。                

unique_ptr 的初始化除了使用shared_ptr相同的 make_unique 外还可以使用 move 函数。              
`unique_ptr<int> p2 = move(p1);  //p1也要是unique_ptr类型`            

**unqiue_ptr作为右值可以赋值给shared_ptr类型，但是unqiue_ptr不能赋值给unique_ptr类型(unqiue_ptr是独占类型不允许两个指针指向同一个内存地址，可以使用move置空以赋值)**                
`unique_ptr<int> p2 = p1; //不允许`               
`shared_ptr<int> p2 = make_unique<int>(10);`               

#### unique_ptr常用操作              
- get  --    获取指针地址            
- release  --    解除智能指针与内存的关联，返回值为智能指针指向的地址               
- reset              

unique_ptr 的删除器与shared_ptr不同，unique_ptr的删除器有一个删除器类型。              
`typedef void (*pf) (int *);   //定义一个删除器类型`           
`unique_ptr<int, pf> p(new int(10), fun);`            


[源代码--智能指针](../assets/Source/%E6%8C%87%E9%92%88/智能指针.cpp)            


## sizeof(ptr)             
指针是一个地址，所以对于普通的指针而言，其占用的内存空间大小是固定的(操作系统的位数)             
但是对于指针指针，但 shared_ptr 原生包含一个引用计数器，所以 shared_ptr 占用的内存大小为普通指针内存大小的 2 倍 —— 64位操作系统下是 16 字节         
unique如果包含自定义删除器，其大小是 16 字节。如果不包含自定义删除器，其大小是 8 字节。         