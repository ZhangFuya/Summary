**面向对象：对一个事物进行抽象，并将抽象出来的属性和行为放入到一个类中。对类中的属性和行为加以包装，使类中的属性和行为能够满足特定的需求(对内可见对外,只暴露想要暴露的内容)。为更加真实的模拟世界，对各个类进行分层，并在层级之间建立灵活的访问方法**。                

## 抽象
**抽象** -- 面向对象的前提条件                
**类**   -- 面向对象的基石            

抽象，大白话就是 提取、概括。                        
我们将一类事物所具有的共同的特性进行概述，比如人。一个人有身高、体重、年龄吧，绝大多数人能吃饭、行走、说话吧。当我们一个人具有的种种形态和动作放在一起时 人{身高、体重、年龄、吃饭、睡觉、行走}，也就是在进行抽象这一行为。                     


## 类
**抽象** -- 面向对象的前提条件                   
**类**   -- 面向对象的基石               

#### 类的介绍
类是一个模板，它描述一类对象的行为和状态(属性和行为)。                     

#### 类的声明          
类是一种用户自定义类型，使用关键字 `class` 进行声明，并使用 `{ }` 来表明其边界。                 
声明格式： `class class_name { ... }`               

#### 类的成员             
类的成员一般分为：成员属性 和 成员方法              
必须注意一点：所有的成员方法，其第一个参数都是一个指向本类的指针，this指针。                
- this指针指向本类，可以通过this指针来访问本类的成员。但是 this 指针不能访问静态成员(静态属性、静态方法都不行)            
- this指针是成员方法的第一个参数，是隐藏的，无需被再次声明。             


#### 类的对象
类是抽象，那么对象就是具体。通过为类的属性赋予对应实体的属性，来描述一个具体的事物，比如 : 人{身高、体重、年龄......}，我通过指定具体的身高、年龄、体重......(身高 = 175，体重 = 120，年龄 = 20，住址 = xxx...)，当我使用的属性足够时我就能刻画出一个具体的人来。这就是通过类来构建一个对象                        
`类是一种类型，创建对象的语法和创建基本数据类型相似 class_name object;`                           


#### 构造和析构函数
构造函数和析构函数是一种特殊的函数，两者的形参都是本类对象的引用。                         
其中，构造函数的作用是在对象被创建的时候初始化该对象。析构函数的作用是完成对象被删除前的一些清理工作。            
特别的：                   
1. 构造函数与析构函数都没有返回值。这是系统赋予两者权力(一定要注意：两者的返回值不写任何的内容，连void都不写，因为两者就是不返回任何的内容哪怕是空都不返回)。                     
2. 构造函数与析构函数的函数名均与类名相同。             
3. 析构函数前边有一个 `~`  ,这个小符号一定要注意不能丢。                 
4. 不写构造与析构函数，系统会调用默认的构造与析构函数。                   
5. 默认的构造与析构函数，就是个空实现无任何语句                    
6. **如果重载了构造函数，那么一定一定要注意，无参构造一定要有**。                 

构造函数的分类：                  
构造函数可以分为：无参构造，有参构造，以及拷贝构造。                      
除了this指针外，如果构造函数带有参数就称为有参构造，构造函数不带任何参数就称为无参构造。拷贝构造指的是构造函数的参数是该类本身的引用。                 
```c++
//无参构造
//无参构造参数列表只有一个this指针
CLASS_Name::CLASS_Name();
//有参构造,除了this指针外还有其他参数
CLASS_Name::CLASS_Name(var_Type, ......);
//拷贝构造，参数类型是类本身的引用
CLASS_Name::CLASS_Name(CLASS_Name &cls); //语法规定：必须要加上引用符号(&),
```

[源代码--类的使用举例](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8.cpp)     


#### 封装
建议创建过类对象再看封装的知识。             
封装 -- 就是将抽象出来的属性和行为按照需求进行包装。           
同上，我们仍是以人来举例。人{身高、体重、年龄、吃饭、睡觉、行走}                
但是对于很多人来说，他们不愿意对外暴露自己的身高、体重等信息。这是很多人都会想到将这些敏感信息隐藏起来，只有自己能调用不就好了。           
再假设一个场景：把大象装到冰箱里要三步。打开冰箱、放入大象、关上冰箱。对于人来说行走也可以分为三步：起身、左脚向前迈、右脚向前迈(当然你也可以根据自己的想法划分更多、更细致的步骤)。                
**这种将抽象出来的内容进行处理、包装，进而实现特定的需求就叫做封装**           
封装可以被认为是一个保护屏障，防止外部的类的随机访问。               

#### 封装的实现手段
**大多数面向对象都是通过权限控制来实现封装的**              
C++中类的成员有三种权限：公有、私有、保护型           
public  --  任意地点都能访问           
private  --  只有在本类中才能访问(作用域 :: 内)             
protected  --  多用于继承，子类可访问，其他类不能访问           

#### 静态成员
声明时使用 static 关键字进行声明的成员属性和成员方法就叫做静态成员属性和静态成员方法。               
**一旦使用 static 进行声明的成员，则无法通过 this 指针进行访问。**                  
特别的：              
1. 静态成员方法只能引用属于该类的静态成员属性和静态成员方法                  
2. **静态成员**都能通过 **对象名.成员名** 或者 **类名::成员名** 进行访问                
3. 一定要注意静态成员是可以不用创建对象直接访问的                  
4. 对于静态成员属性，必须知道两点：                 
- 静态成员属性必须在类外初始化(并使用 :: 表明所属的类)           
- 同一个类构建出来的所有对象拥有的是同一个静态成员属性           


#### 友元
友元  --  破环封装性的手段              
友元分为友元函数和友元类。两者的声明如下:                         
`friend void dispaly(className);  void dispaly(className){} //注意这里没有作用域修饰符::`             
`friend class class_nameB;(classA的public权限里声明，classA可以访问classB中的任意成员)`             
特别的：                      
1. 友元函数声明在public权限下，但是在类外定义时，不需要加作用域修饰符::              
2. 友元函数不是本类中的成员，也就没有了this指针，所以必须为其指定参数            
3. 友元类是被访问的类中，添加引用类为友元类                   

[源代码--封装举例](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-%E5%B0%81%E8%A3%85.cpp)         

## 继承             
**继承 -- 就是赋予不同的类以层次。**           
对比于现实世界，人可以分为：学生、教师、医生、农民等等，而学生又可以分为：大学生、高中生、初中生等等......。当然计算机中也可以根据不同的人群进行抽象，进而抽象出一个个独立的类。但是在这个过程中不难看出来，每个独立的类中，年龄、身高、行走、休息.......这些属性和行为都是重复的。所以设计者们就想到了使用一个基类包含所有重复的属性和行为，让需要这些属性和行为的类从基类中获取相应的内容，进而避免重复定义相同的属性和行为。这一思想就是继承。而一个类从另一个类获取属性或行为，也使得两个类之间有了联系，产生了层次结构。                    

#### 继承的语法
和许多编程语言不同的是，C++支持多继承。两种方式继承语法基本相同                 
`class 子类名 : [继承方式]父类名, [继承方式]父类名, ......`               
`继承方式有：public、private、protected`                
注意两点即可：         
1. 继承使用 `:`  用以分割子类和父类                  
2. 继承方式，不写默认为 `private` 。当继承多个类时，父类之间使用逗号分隔               

#### 继承方式的区别        
C++中的继承方式有三种，分别是：公有(public)、私有(private) 以及 保护继承(protected)。             
继承是在子类和父类之间建立通道，而继承方式影响的是子类接收父类成员的方式。               
首先，我们要明确一点，**父类中为 private 权限的所有成员，除了其本身外，任何类均无访问权限，其子类也没有**。采用隔离模型(多继承二义性中代码块中的推测)，我们不妨认为父类中 private 权限的所有成员，无法突破隔离(因其无法突破隔离，子类根本无法访问，因此讨论其在子类中的权限毫无意义)。那么剩下的只有 public 权限和 protected 权限。                 
1. 公有继承         
子类接收父类中的成员后，对所有的成员权限不做修改          
2. 私有继承            
子类以 private 权限接收父类中的成员(public、protected达到子类后均为 private 权限)             
3. 保护权限          
子类以 protected 权限接收父类中的成员(public\protected到达子类后均转为 protected 权限)             

```c++
一个类中声明为 private 权限的所有成员，除本类外任何类无权访问，子类也不行
对象只能访问类中为 public 权限的成员，因此私有、保护继承后子类对象不能访问父类成员。
```

[源代码--多继承中以及继承方式](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/05-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F.cpp)            


#### 多继承中的二义性          
在多继承中，当两个及以上的父类存在同名变量时，子类继承来的成员也就有了相同命名的成员。            
多继承二义性的解决方法：          
1. 使用虚函数，解决成员方法同名的问题            
2. 使用 `类名::成员名` 显性访问             

```c++
一个推测：
由解决二义性的方法2，我们可以有一个大胆的猜测：
子类继承父类，继承来的成员是存放在子类的空间中的，就相当于copy了一份父类中的所有内容。
但是，由于封装性，继承来的父类是被隔离的。
访问子类中的成员，先去子类中查询，找不到再去被隔离的空间中查询。

由以上的推测，我们还可以推测出：
1. 子类有与父类完全相同的成员，访问子类成员，不会访问父类中的
2. 父类中有同名成员，但未被访问，没影响。但是要小心这个隐藏的炸弹
3. 父类的同名成员一定有一个访问策略。极有可能与子类构建父类的顺序有关。
```

[源代码--多继承中的二义性](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/06-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%BA%8C%E4%B9%89%E6%80%A7.cpp)                


### 构造与析构函数            
构造函数主要用于创建对象时的初始化工作，析构函数主要用于对象销毁前的清理工作。针对只有一个对象的函数，自然是先调用构造函数再调用析构函数。但往往函数中不止一个对象。针对于构造函数的调用时机以及构造与析构的顺序，这里进行深入的探究            
- 构造函数的调用时机        
**构造函数在创建对象时被调用，所以什么时候会创建对象什么时候就会调用构造函数。而计算构造函数的调用时唯一的检验标准就是，是否为为类类型的变量申请了内存。**            
通常以下情景都会创建一个对象：           
1. 声明对象时          
2. 参数是类类型，并进行值传递时           
参数是类类型会调用拷贝构造函数，生成一个临时对象，当函数执行完成这个临时对象会被销毁            
```c++
CLASS_A cls_a_2(cls_a_1);
这是一个拷贝构造函数，因为函数的参数是一个类类型，所以编译器会先为参数 cls_a_1 调用拷贝构造函数生成一个临时对象。然后才是为 cls_a_2 调用拷贝构造函数.而且当该语句执行完 cls_a_1 的生命周期也就结束了， cls_a_1 进行销毁，执行析构函数

这是进行的值拷贝，生成临时对象，所以参数会调用拷贝构造函数(要给形参申请一块空间用于存放数据啊)
但是如果进行的是地址传递，编译器不需要为参数申请空间，参数的构造函数也就不会被执行
void CLASS_A::class_as_para(CLASS_Name &cls); //此时不需要为 cls 申请空间， 
											  //CLASS_Name的构造函数不会被执行
```
3. 返回值是类类型时          
注意，当返回值是值类型，编译器可能会对语句进行优化，进而产生我们不希望的结果。建议使用 VS 并关闭优化器以便效果的展示。          

- 构造与析构的顺序           
只构建了一个对象那必然是先构造在析构了             
当创建多个对象时，**先构造的后销毁。**             

- 继承中构造与析构的顺序             
父类先构造，后析构             

- 多继承中构造与析构的顺序             
父类按照继承列表中的顺序构造，并且按照先构造后销毁的顺序进行析构           
子类在所有的父类构造完成后构造，在所有父类析构前析构           

**概括来说：构造与析构的顺序相反，先构造的后析构。**                 


[源代码--构造函数的调用时机](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA.cpp)          
[源代码--构造与析构顺序](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/04-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F.cpp)           


## 多态     
如果说继承给予了不同的类以层次变化，那么多态就是层级之间的灵活变化(以达到函数复用的效果)。              
所谓的灵活变化一般体现在两个方面：1.多态允许函数名的复用，我们称之为函数的重载。            
2.多态允许子类对象的地址赋值给基类指针以实现类的灵活使用。       
针对于这两个方面，多态也常常被分为两类：静态多态(情况1) 和 动态多态(情况2)      

#### 多态的分类    
多态一般被分为两类，静态多态 和 动态多态      
- 静态多态      
函数重载 和 运算符重载属于静态多态(复用函数名)      
静态多态是早绑定(编译阶段确定函数地址)      
- 动态多态         
派生类 和 虚函数 实现运行时多态       
动态多态是晚绑定(运行阶段确定函数地址)     
 
C++中多态通常指的是动态多态     


### 静态多态
函数重载 和 运算符重载      
1. 函数重载指的是 同一作用域下 函数名相同，参数列表不同的函数列表      
2. 运算符重载本质上也是函数重载      
运算符的重载的一般语法 `返回值类型 operator运算符(参数列表);`       
通常运算符重载后返回值类型为自身对应的类类型，所以运算符重载也可以写为      
`类名 operator运算符(参数列表);`        
```c++ 
重载注意点：    
1. 仔细看函数重载的概念，函数重载要求的是 同一作用域下， 简单理解就是在一个类中      
2. 函数重载要求函数名必须相同，参数列表不同。所谓的参数列表不同，可以是参数个数不同，也可以是参数列表中参数类型不同(一个参数类型不同就是发生了重载)。但参数名以及返回值类型不能作为函数重载的依据。        
3. 运算符重载本质上也是函数重载的一种      

重载运算符的必要性：     
我们要知道 +、 -、 *、 /、 %、 [ ] 这些运算符之所以能够根据运算符周围的内容进行运算，是因为我们已经提前定义了一个运算符在遇到对应的类型时做出什么样的反应，这也就是我们通常所说的计算。但是类作为一个类型，它(类类型)的种类实在太多了，而且有些类根本就用不到计算。因此，设计者们把运算符独立出来了，如果需要对一个类进行的计算，那定义运算符在遇到这个类的时候进行什么样的反应就可以了。因此对一些类进行运算符重载就尤为重要。      
```

[源代码--函数重载](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/07-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD.cpp)           

### 动态多态     
动态多态主要有两种：1. (类型兼容)子类地址可以赋值给基类指针   2.  虚函数      

#### 类型兼容      
子类地址可以赋值给基类指针，具体表现为：      
- 子类对象可以赋值给基类对象      
- 子类对象可以初始化基类的引用      
- 指向子类的指针也可以指向基类     
- 基类对象名、指针只能使用从基类的成员     

#### 虚函数     
所谓虚函数，就是在声明时前面加了 **virtual 关键字的成员函数**。包含虚函数的类称为“多态类”。       
虚函数就是覆盖——子类重写父类的同名虚函数       
虚函数实现了基类指针访问派生类成员       
注意点：当一个成员函数被声明为虚函数后，其子类的同名函数自动成为虚函数         
虚函数有以下几个方面的限制:       
- 只有类的成员函数才能成为虚函数。        
- 静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。        
- 内联函数不能是虚函数，因为内联函数不能在运行中动态确定其位置。       
-  构造函数不能是虚函数，析构函数通常是虚函数       

[源代码--虚函数](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/08-%E8%99%9A%E5%87%BD%E6%95%B0.cpp)               



### 函数重载、函数重写与函数重定义
这个问题还是值得探究一下的。        
函数重载：同一作用域下，函数名相同但函数的形参列表不同。我们就说函数发生了重载。       
函数重写：父类中的虚函数在子类中重新实现        
函数重定义：子类函数名与父类函数名相同。        
注意：函数重写 与 函数重定义 都能实现对基类同名函数的隐藏      


### 纯虚函数与抽象类      
- 在成员函数的形参后面写上 =0 ，则成员函数为纯虚函数(语法：`virtual  类型 函数名(参数表列)=0;`)      
- 包含纯虚函数(哪怕只有一个纯虚函数)的类被称为抽象类     

注意点：      
1. 纯虚函数不能被继承。当基类是抽象类时，在派生类中必须给出基类中纯虚函数的定义，或在该类中再声明其为纯虚函数。      
2. 只有在派生类中给出基类所有纯虚函数的实现时，该派生类才不再成为抽象类。      

[源代码--纯虚函数与抽象类](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/09-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0.cpp)     