**面向对象：对一个事物进行抽象，并将抽象出来的属性和行为放入到一个类中。对类中的属性和行为加以包装，使类中的属性和行为能够满足特定的需求(对内可见对外,只暴露想要暴露的内容)。为更加真实的模拟世界，对各个类进行分层，并在层级之间建立灵活的访问方法**。                

## 抽象
**抽象** -- 面向对象的前提条件                
**类**   -- 面向对象的基石            

抽象，大白话就是 提取、概括。                        
我们将一类事物所具有的共同的特性进行概述，比如人。一个人有身高、体重、年龄吧，绝大多数人能吃饭、行走、说话吧。当我们一个人具有的种种形态和动作放在一起时 人{身高、体重、年龄、吃饭、睡觉、行走}，也就是在进行抽象这一行为。                     


## 类
**抽象** -- 面向对象的前提条件                   
**类**   -- 面向对象的基石               

#### 类的介绍
类是一个模板，它描述一类对象的行为和状态(属性和行为)。                     

#### 类的声明          
类是一种用户自定义类型，使用关键字 `class` 进行声明，并使用 `{ }` 来表明其边界。                 
声明格式： `class class_name { ... }`               

#### 类的成员             
类的成员一般分为：成员属性 和 成员方法              
必须注意一点：所有的成员方法，其第一个参数都是一个指向本类的指针，this指针。                
- this指针指向本类，可以通过this指针来访问本类的成员。但是 this 指针不能访问静态成员(静态属性、静态方法都不行)            
- this指针是成员方法的第一个参数，是隐藏的，无需被再次声明。             


#### 类的对象
类是抽象，那么对象就是具体。通过为类的属性赋予对应实体的属性，来描述一个具体的事物，比如 : 人{身高、体重、年龄......}，我通过指定具体的身高、年龄、体重......(身高 = 175，体重 = 120，年龄 = 20，住址 = xxx...)，当我使用的属性足够时我就能刻画出一个具体的人来。这就是通过类来构建一个对象                        
`类是一种类型，创建对象的语法和创建基本数据类型相似 class_name object;`                           


#### 构造和析构函数
构造函数和析构函数是一种特殊的函数，两者的形参都是本类对象的引用。                         
其中，构造函数的作用是在对象被创建的时候初始化该对象。析构函数的作用是完成对象被删除前的一些清理工作。            
特别的：                   
1. 构造函数与析构函数都没有返回值。这是系统赋予两者权力(一定要注意：两者的返回值不写任何的内容，连void都不写，因为两者就是不返回任何的内容哪怕是空都不返回)。                     
2. 构造函数与析构函数的函数名均与类名相同。             
3. 析构函数前边有一个 `~`  ,这个小符号一定要注意不能丢。                 
4. 不写构造与析构函数，系统会调用默认的构造与析构函数。                   
5. 默认的构造与析构函数，就是个空实现无任何语句                    
6. **如果重载了构造函数，那么一定一定要注意，无参构造一定要有**。                 

构造函数的分类：                  
构造函数可以分为：无参构造，有参构造，以及拷贝构造。                      
除了this指针外，如果构造函数带有参数就称为有参构造，构造函数不带任何参数就称为无参构造。拷贝构造指的是构造函数的参数是该类本身的引用。                 
```c++
//无参构造
//无参构造参数列表只有一个this指针
CLASS_Name::CLASS_Name();
//有参构造,除了this指针外还有其他参数
CLASS_Name::CLASS_Name(var_Type, ......);
//拷贝构造，参数类型是类本身的引用
CLASS_Name::CLASS_Name(CLASS_Name &cls); //语法规定：必须要加上引用符号(&),
```

[类的使用举例](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/01-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8.cpp)     


#### 封装
建议创建过类对象再看封装的知识。             
封装 -- 就是将抽象出来的属性和行为按照需求进行包装。           
同上，我们仍是以人来举例。人{身高、体重、年龄、吃饭、睡觉、行走}                
但是对于很多人来说，他们不愿意对外暴露自己的身高、体重等信息。这是很多人都会想到将这些敏感信息隐藏起来，只有自己能调用不就好了。           
再假设一个场景：把大象装到冰箱里要三步。打开冰箱、放入大象、关上冰箱。对于人来说行走也可以分为三步：起身、左脚向前迈、右脚向前迈(当然你也可以根据自己的想法划分更多、更细致的步骤)。                
**这种将抽象出来的内容进行处理、包装，进而实现特定的需求就叫做封装**           
封装可以被认为是一个保护屏障，防止外部的类的随机访问。               

#### 封装的实现手段
**大多数面向对象都是通过权限控制来实现封装的**              
C++中类的成员有三种权限：公有、私有、保护型           
public  --  任意地点都能访问           
private  --  只有在本类中才能访问(作用域 :: 内)             
protected  --  多用于继承，子类可访问，其他类不能访问           

#### 静态成员
声明时使用 static 关键字进行声明的成员属性和成员方法就叫做静态成员属性和静态成员方法。               
**一旦使用 static 进行声明的成员，则无法通过 this 指针进行访问。**                  
特别的：              
1. 静态成员方法只能引用属于该类的静态成员属性和静态成员方法                  
2. **静态成员**都能通过 **对象名.成员名** 或者 **类名::成员名** 进行访问                
3. 一定要注意静态成员是可以不用创建对象直接访问的                  
4. 对于静态成员属性，必须知道两点：                 
- 静态成员属性必须在类外初始化(并使用 :: 表明所属的类)           
- 同一个类构建出来的所有对象拥有的是同一个静态成员属性           


#### 友元
友元  --  破环封装性的手段              
友元分为友元函数和友元类。两者的声明如下:                         
`friend void dispaly(className);  void dispaly(className){} //注意这里没有作用域修饰符::`             
`friend class class_nameB;(classA的public权限里声明，classA可以访问classB中的任意成员)`             
特别的：                      
1. 友元函数声明在public权限下，但是在类外定义时，不需要加作用域修饰符::              
2. 友元函数不是本类中的成员，也就没有了this指针，所以必须为其指定参数            
3. 友元类是被访问的类中，添加引用类为友元类                   

[封装举例](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/02-%E5%B0%81%E8%A3%85.cpp)         

## 继承             
**继承 -- 就是赋予不同的类以层次。**           
对比于现实世界，人可以分为：学生、教师、医生、农民等等，而学生又可以分为：大学生、高中生、初中生等等......。当然计算机中也可以根据不同的人群进行抽象，进而抽象出一个个独立的类。但是在这个过程中不难看出来，每个独立的类中，年龄、身高、行走、休息.......这些属性和行为都是重复的。所以设计者们就想到了使用一个基类包含所有重复的属性和行为，让需要这些属性和行为的类从基类中获取相应的内容，进而避免重复定义相同的属性和行为。这一思想就是继承。而一个类从另一个类获取属性或行为，也使得两个类之间有了联系，产生了层次结构。                    

#### 继承的语法
和许多编程语言不同的是，C++支持多继承。两种方式继承语法基本相同                 
`class 子类名 : [继承方式]父类名, [继承方式]父类名, ......`               
`继承方式有：public、private、protected`                
注意两点即可：         
1. 继承使用 `:`  用以分割子类和父类                  
2. 继承方式，不写默认为 `private` 。当继承多个类时，父类之间使用逗号分隔               

#### 继承方式的区别        
C++中的继承方式有三种，分别是：公有(public)、私有(private) 以及 保护继承(protected)。             
继承是在子类和父类之间建立通道，而继承方式影响的是子类接收父类成员的方式。               
首先，我们要明确一点，**父类中为 private 权限的所有成员，除了其本身外，任何类均无访问权限，其子类也没有**。采用隔离模型(多继承二义性中代码块中的推测)，我们不妨认为父类中 private 权限的所有成员，无法突破隔离(因其无法突破隔离，子类根本无法访问，因此讨论其在子类中的权限毫无意义)。那么剩下的只有 public 权限和 protected 权限。                 
1. 公有继承         
子类接收父类中的成员后，对所有的成员权限不做修改          
2. 私有继承            
子类以 private 权限接收父类中的成员(public、protected达到子类后均为 private 权限)             
3. 保护权限          
子类以 protected 权限接收父类中的成员(public\protected到达子类后均转为 protected 权限)             

```c++
一个类中声明为 private 权限的所有成员，除本类外任何类无权访问，子类也不行
对象只能访问类中为 public 权限的成员，因此私有、保护继承后子类对象不能访问父类成员。
```

[多继承中以及继承方式](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/05-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F.cpp)            


#### 多继承中的二义性          
在多继承中，当两个及以上的父类存在同名变量时，子类继承来的成员也就有了相同命名的成员。            
多继承二义性的解决方法：          
1. 使用虚函数，解决成员方法同名的问题            
2. 使用 `类名::成员名` 显性访问             

```c++
一个推测：
由解决二义性的方法2，我们可以有一个大胆的猜测：
子类继承父类，继承来的成员是存放在子类的空间中的，就相当于copy了一份父类中的所有内容。
但是，由于封装性，继承来的父类是被隔离的。
访问子类中的成员，先去子类中查询，找不到再去被隔离的空间中查询。

由以上的推测，我们还可以推测出：
1. 子类有与父类完全相同的成员，访问子类成员，不会访问父类中的
2. 父类中有同名成员，但未被访问，没影响。但是要小心这个隐藏的炸弹
3. 父类的同名成员一定有一个访问策略。极有可能与子类构建父类的顺序有关。
```

[多继承中的二义性](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/06-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%BA%8C%E4%B9%89%E6%80%A7.cpp)                


### 构造与析构函数            
构造函数主要用于创建对象时的初始化工作，析构函数主要用于对象销毁前的清理工作。针对只有一个对象的函数，自然是先调用构造函数再调用析构函数。但往往函数中不止一个对象。针对于构造函数的调用时机以及构造与析构的顺序，这里进行深入的探究            
- 构造函数的调用时机        
**构造函数在创建对象时被调用，所以什么时候会创建对象什么时候就会调用构造函数。而计算构造函数的调用时唯一的检验标准就是，是否为为类类型的变量申请了内存。**            
通常以下情景都会创建一个对象：           
1. 声明对象时          
2. 参数是类类型，并进行值传递时           
参数是类类型会调用拷贝构造函数，生成一个临时对象，当函数执行完成这个临时对象会被销毁            
```c++
CLASS_A cls_a_2(cls_a_1);
这是一个拷贝构造函数，因为函数的参数是一个类类型，所以编译器会先为参数 cls_a_1 调用拷贝构造函数生成一个临时对象。然后才是为 cls_a_2 调用拷贝构造函数.而且当该语句执行完 cls_a_1 的生命周期也就结束了， cls_a_1 进行销毁，执行析构函数

这是进行的值拷贝，生成临时对象，所以参数会调用拷贝构造函数(要给形参申请一块空间用于存放数据啊)
但是如果进行的是地址传递，编译器不需要为参数申请空间，参数的构造函数也就不会被执行
void CLASS_A::class_as_para(CLASS_Name &cls); //此时不需要为 cls 申请空间， 
											  //CLASS_Name的构造函数不会被执行
```
3. 返回值是类类型时          
注意，当返回值是值类型，编译器可能会对语句进行优化，进而产生我们不希望的结果。建议使用 VS 并关闭优化器以便效果的展示。          

- 构造与析构的顺序           
只构建了一个对象那必然是先构造在析构了             
当创建多个对象时，**先构造的后销毁。**             

- 继承中构造与析构的顺序             
父类先构造，后析构             

- 多继承中构造与析构的顺序             
父类按照继承列表中的顺序构造，并且按照先构造后销毁的顺序进行析构           
子类在所有的父类构造完成后构造，在所有父类析构前析构           

**概括来说：构造与析构的顺序相反，先构造的后析构。**                 


[构造函数的调用时机](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/03-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA.cpp)          
[构造与析构顺序](../Source/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/04-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F.cpp)           


## 多态


#### 函数重载、函数重写与函数重定义
这个问题还是值得探究一下的。
函数重载：同一作用域下，函数名相同但函数的形参列表不同。我们就说函数发生了重载。
函数重写：父类中的虚函数在子类中重新实现
函数重定义：子类函数名与父类函数名相同。

特别的，运算符重载










类似的我们还能对许多事物进行抽象。但是我们不难看出这样的抽象是很混乱的(所有抽象出来的内容都放在一起杂乱无章，无从下手)。为了更好地使用抽象出来的内容，我们对其进行包装。
1. 予其类别(封装)
2. 赋予层次(继承)
3. 予以变化(多态)
这样一来抽象出的内容在模拟现实层面就能得到极大的提升，也由此引出了面向对象的三大核心思想——封装、继承 和 多态。
由上边的结构我们可以看出来：面向对象是基于抽象进行设计的；面向对象三要意：封装、继承、多态；面向对象三要意之间是递进的关系；
**面向对象的实现是通过封装类来实现的**。
```c++
封装,就是对抽象的内容进行分类整理，常见的分类方式就按照是否连续分为属性和行为
比如，我们将年龄划分为属性(非连续性)，而将年龄增长划分为行为(连续性)，并将年龄增长这一过程视为一个整体,封装为一个函数(实际上任何类似于打包、整理的过程我们都能称其为封装)。
继承,就是赋予不同的类以层次。有了层次才能更加直观的感受类与类之间的关系。继承设计的目的就是为了代码的复用。你想人有年龄、学生有年龄、教师有年龄。如果我创建三个类，每个类都写一个年龄先不说每个人起名字是不是一样，单就说创建三个年龄，就很让人心烦了。为此设计者很巧妙的设计出了继承这一思想。
多态,是予以变化，也就是更加灵活的使用
```