**字符串是以 ASCII 码的 0 为结尾的字符数组**
对字符串的认识其实只要知道以下几个知识点就足够了：
1. 字符串是字符数组，但是该字符数组必须是以 ASCII 码的 0 为结尾的
2. ASCII 的 0 是什么。
	这个ASCII的 0 呀，就是 空，可以认为什么都没有，一片虚无。
	这里有一个知识点就是，ASCII的 0 与 字符0，很多人区分不好。
	其实，只要理解字符0(‘0’)就很容易区分了。看一个例子
	```
	char c = 0;        
	char c = '0';
	这看着有点绕，那不妨看看下边的：
	char c = 65；
	char c = 'E';
	第一句呢，是使用ASCII码对c进行的初始化，变量c的值就是码值65
	第二句，是使用字符对c进行初始化，变量c中存储的不是E而是E的ASCII码69对吧
	相应的char c = 0; 与 char c = '0'; 中前者存放的是码值为 0 的空字符，
	而后者存放的码值为 48 的字符0。
	```
	
3. 什么样的字符数组才是以 0 结尾的字符数组
```
char arr[5] = {'a', 'b', 'c', 'd', 'e'};
这样的字符数组是以 0 为结尾的字符数组吗？很显然不是。
char arr[5] = {'a', 'b', 'c', 'd', '0'}; 是以 0 为结尾吗？因为字符0（'0'），不是ASCII的0，所以这里也不是以0结尾的字符数组
char arr[5] = {'a', 'b', 'c', 'd', 0}; 才是以0结尾的字符数组，才是字符串。
```

因为一维数组在定义时可以省略宽度，由编译器自动推导，因此字符串常常书写为：
`char chr_arr[] = "abcdef"; 或者 char * str = "abcdef";`
这两种写法都要注意，字符数组所申请的空间不是6单位字节，而是7单位字节。
特别的：
- 第一种写法是，声明了一个7单位字节的chr_arr，chr_arr表示所申请空间的首地址
- 第二种写法是，声明一个指针指向了字符数组"abcdef"所在的空间。
因为两者的差异，导致了两者虽然在外形上相近，但是在使用上有着很大的不同。
1. chr_arr 表示的是数组的首地址。因此chr_arr的值不能修改。但数组元素的值可以修改，也就是 chr_arr[0] = 65; 可以。
2. chr_arr表示的是字符串，所以字符串函数如 strcat、strcmp、strcpy对str_arr同样适用。但是在使用这些字符串函数时候一定要注意 chr_arr 的宽度。
4. str 是一个指向char数组的指针，因此可以将任意地址量传递给 str。
5. 如果str指向的是具有常量性质的值，那么 \*str = value; 或 str\[0\] = value; 无法使用
6. str表示的是一个地址，如果指向的是一个常量类型的字符数组，
	那么 strcat、strcpy函数无法使用。
	示例如图：
		![[02-String1.png]]


练习题：不使用库函数实现如strlen、strcpy、strcmp之类的函数

惯用语句：
while(\*s) &nbsp;&nbsp; s++;
while(\*s++)
都是遍历字符串的惯用法，第一个版本最终使s指向空字符。第二个更加简洁，但是第二种写法s最后指向空字符后边的位置
while(\*p++ = *s2++);
完美实现字符串的复制



### 指针数组
```c
char *planets[] = {
	"Mercury", "Venus", "Earth",
	"Mars", "Jupiters", "Saturn",
	"Uranus", "Neptune", "Pluto"
};
```

planets 是一个数组，包含多个指向字符串的指针。
