**面向对象：对一个事物进行抽象，并将抽象出来的属性和行为放入到一个类中。对类中的属性和行为加以包装，使类中的属性和行为能够满足特定的需求(对内可见对外,只暴露想要暴露的内容)。为更加真实的模拟世界，对各个类进行分层，并在层级之间建立灵活的访问方法**。

## 抽象
**抽象** -- 面向对象的前提条件
**类**   -- 面向对象的基石

抽象，大白话就是 提取、概括。
我们将一类事物所具有的共同的特性进行概述，比如人。一个人有身高、体重、年龄吧，绝大多数人能吃饭、行走、说话吧。当我们一个人具有的种种形态和动作放在一起时 人{身高、体重、年龄、吃饭、睡觉、行走}，也就是在进行抽象这一行为。


## 类
**抽象** -- 面向对象的前提条件
**类**   -- 面向对象的基石

#### 类的介绍
类是一个模板，它描述一类对象的行为和状态(属性和行为)。

#### 类的声明
类是一种用户自定义类型，使用关键字 `class` 进行声明，并使用 `{ }` 来表明其边界。
声明格式： `class class_name { ... }`

#### 类的成员
类的成员一般分为：成员属性 和 成员方法
必须注意一点：所有的成员方法，其第一个参数都是一个指向本类的指针，this指针。
- this指针指向本类，可以通过this指针来访问本类的成员。但是 this 指针不能访问静态成员(静态属性、静态方法都不行)
- this指针是成员方法的第一个参数，是隐藏的，无需被再次声明。


#### 类的对象
类是抽象，那么对象就是具体。通过为类的属性赋予对应实体的属性，来描述一个具体的事物，比如 : 人{身高、体重、年龄......}，我通过指定具体的身高、年龄、体重......(身高 = 175，体重 = 120，年龄 = 20，住址 = xxx...)，当我使用的属性足够时我就能刻画出一个具体的人来。这就是通过类来构建一个对象
`类是一种类型，创建对象的语法和创建基本数据类型相似 class_name object;`


#### 构造和析构函数
构造函数和析构函数是一种特殊的函数，两者的形参都是本类对象的引用。
其中，构造函数的作用是在对象被创建的时候初始化该对象。析构函数的作用是完成对象被删除前的一些清理工作。
特别的：
1. 构造函数与析构函数都没有返回值。这是系统赋予两者权力(一定要注意：两者前边不写任何的内容，连void都不写，因为两者就是不返回任何的内容哪怕是空都不返回)。
2. 构造函数与析构函数的函数名均与类名相同。
3. 析构函数前边有一个 `~`  ,这个小符号一定要注意不能丢。
4. 不写构造与析构函数，系统会调用默认的构造与析构函数。
5. 默认的构造与析构函数，就是个空实现无任何语句
6. **如果重载了构造函数，那么一定一定要注意，无参构造一定要有**。

[类的使用举例](../../C%2B%2B%E6%BA%90%E4%BB%A3%E7%A0%81/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/01-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8.cpp)


#### 封装
建议创建过类对象再看封装的知识。
封装 -- 就是将抽象出来的属性和行为按照需求进行包装。
同上，我们仍是以人来举例。人{身高、体重、年龄、吃饭、睡觉、行走}
但是对于很多人来说，他们不愿意对外暴露自己的身高、体重等信息。这是很多人都会想到将这些敏感信息隐藏起来，只有自己能调用不就好了。
再假设一个场景：把大象装到冰箱里要三步。打开冰箱、放入大象、关上冰箱。对于人来说行走也可以分为三步：起身、左脚向前迈、右脚向前迈(当然你也可以根据自己的想法划分更多、更细致的步骤)。
**这种将抽象出来的内容进行处理、包装，进而实现特定的需求就叫做封装**
封装可以被认为是一个保护屏障，防止外部的类的随机访问。

#### 封装的实现手段
**大多数面向对象都是通过权限控制来实现封装的**
C++中类的成员有三种权限：公有、私有、保护型
public  --  任意地点都能访问
private  --  只有在本类中才能访问(作用域 :: 内)
protected  --  多用于继承，子类可访问，其他类不能访问

#### 静态成员
声明时使用 static 关键字进行声明的成员属性和成员方法就叫做静态成员属性和静态成员方法。
**一旦使用 static 进行声明的成员，则无法通过 this 指针进行访问。**
特别的：
1. 静态成员方法只能引用属于该类的静态成员属性和静态成员方法
2. **静态成员**都能通过 **对象名.成员名** 或者 **类名::成员名** 进行访问
3. 一定要注意静态成员是可以不用创建对象直接访问的
4. 对于静态成员属性，必须知道两点：
- 静态成员属性必须在类外初始化(并使用 :: 表明所属的类)  
- 同一个类构建出来的所有对象拥有的是同一个静态成员属性


#### 友元
友元  --  破环封装性的手段
友元分为友元函数和友元类。两者的声明如下:
`friend void dispaly(className);  void dispaly(className){} //注意这里没有作用域修饰符::`
`friend class class_nameB;(classA的public权限里声明，classA可以访问classB中的任意成员)`
特别的：
1. 友元函数声明在public权限下，但是在类外定义时，不需要加作用域修饰符::
2. 友元函数不是本类中的成员，也就没有了this指针，所以必须为其指定参数
3. 友元类是被访问的类中，添加引用类为友元类

[封装举例](../../C%2B%2B%E6%BA%90%E4%BB%A3%E7%A0%81/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/02-%E5%B0%81%E8%A3%85.cpp)

## 继承



类似的我们还能对许多事物进行抽象。但是我们不难看出这样的抽象是很混乱的(所有抽象出来的内容都放在一起杂乱无章，无从下手)。为了更好地使用抽象出来的内容，我们对其进行包装。
1. 予其类别(封装)
2. 赋予层次(继承)
3. 予以变化(多态)
这样一来抽象出的内容在模拟现实层面就能得到极大的提升，也由此引出了面向对象的三大核心思想——封装、继承 和 多态。
由上边的结构我们可以看出来：面向对象是基于抽象进行设计的；面向对象三要意：封装、继承、多态；面向对象三要意之间是递进的关系；
**面向对象的实现是通过封装类来实现的**。
```c++
封装,就是对抽象的内容进行分类整理，常见的分类方式就按照是否连续分为属性和行为
比如，我们将年龄划分为属性(非连续性)，而将年龄增长划分为行为(连续性)，并将年龄增长这一过程视为一个整体,封装为一个函数(实际上任何类似于打包、整理的过程我们都能称其为封装)。
继承,就是赋予不同的类以层次。有了层次才能更加直观的感受类与类之间的关系。继承设计的目的就是为了代码的复用。你想人有年龄、学生有年龄、教师有年龄。如果我创建三个类，每个类都写一个年龄先不说每个人起名字是不是一样，单就说创建三个年龄，就很让人心烦了。为此设计者很巧妙的设计出了继承这一思想。
多态,是予以变化，也就是更加灵活的使用
```



## 类与封装
封装就是将抽象的元素整合到一个个类中
封装就是对抽象的内容进行分类整理，常见的分类方式就按照是否连续分为属性和行为
比如，我们将年龄划分为属性(非连续性)，而将年龄增长划分为行为(连续性)，并将年龄增长这一过程视为一个整体,封装为一个函数(实际上任何类似于打包、整理的过程我们都能称其为封装)。
类的概念、界限、对象、成员的访问方式、
this指针
构造函数与析构函数(默认构造、拷贝构造、构造与析构顺序)
静态成员、静态成员函数
友元、友元类

## 继承与派生
继承与派生的目的、继承方式以及区别
继承中的构造与析构
函数重载
多继承与环形继承