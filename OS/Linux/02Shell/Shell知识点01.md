Shell脚本就是将完成一个任务的所有命令按照执行的先后顺序，自上而下写入到一个文本文件中，然后给予执行权限。
Shell规范：文件名字要有意义，最好是见明知意
					禁止赋予777权限
					文件名不宜过长，30字节以内，且以.sh为结尾
					执行脚本中，不允许写中文，哪怕是在注释中
					文件开头，应该表明：是谁写的(Author)，什么时间写的(Created Time)，脚本是做什么用的(Script Description)。
					如有必要，还可以添加版本信息、增删内容等内容。 如：				
```			
#Author: ZhangFuya
#Created Time: 22/05/20 13:14
#Script Description: echo HelloWorld
```

```
Shell脚本开头必须指定脚本的运行环境，以 #! 这个特殊的符号组合来组成。如 #!/bin/bash指定该脚本是运行解析由 /bin/bash 来完成 
```

Shell中的注释使用 # 号
`#! 是特殊组合符号，表运行时解析环境，不是注释`

执行Shell脚本由两种方法：1. 给予执行权限  2. 解释器直接运行不需要权限

Shell中的管道：
管道其实就是上一个命令的输出，作为下一个命令的输入

重定向：
```
>    重定向输入  覆盖原数据
>>   重定向追加输入，在原数据的末尾添加
<    重定向输出
<<   重定向追加输出
例如： 
echo hehe > test.txt
echo hehe >> test.txt
wc < test.txt
一个小技巧：使用 > /dev/null 可以将输出内容输出到回收站
/dev/null文件表示回收站
```


一个问题：
Linux  wc命令  `wc < test.txt` 中 < 是追加输出的意思
那到底是把什么追加给什么呢？？？
这条指令与  `wc  test.txt` 的区别又是什么呢？？？
![wc与输出重定向.png](./assets/Shell//wc%E4%B8%8E%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91.png)         
```shell
wc < test.txt 先将test.txt通过文件流打开，之后重定向给wc命令用以统计
wc test.txt 是使用wc命令直接统计 test.txt 中的内容
两者的区别在于来源，即是否使用内存打开文件
两者的区别，通过下图可以有更直观的感受
```
![wc与输出重定向2.png](./assets/Shell/wc%E4%B8%8E%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%912.png)         


$? 可以判断上一条命令是否成功执行。返回0，成功执行。返回非0，未成功执行
$?的返回值是通过程序中的exit() 指令指明的。



Shell中的计算
1. 使用 expr 进行整数运算，但是要注意 \*(乘法) 会被解释为通配符，因此\*(乘法)前要加转义符。如   `expr 1 \* 2 > /dev/null`
2. 使用$( () )括起来需要运算的内容。第二个小括号表示要运算的内容



其实编程很简单，就是三步嘛：输入、运算和输出
输入和输出很简单，剩下的就是运算了
输入与输出
一个程序需要有0个或以上的输入，一个或更多的输出
输入使用read，输出使用的是echo

read命令：默认接收键盘的输入，回车符代表输入结束
-s  不显示输入的内容(不回显)
-t  设置超时时间
-n  设置有效字节数
-p  替代echo进行打印，然后等待输入(我个人不建议使用这个选项)

echo命令：将内容输出到默认显示设备
-n  不换行输出
-e  支持转义字符
一些转义字符： \a   警告声     \b删除前一个字符  

变量：
在编程中，我们总有一些数据需要临时存放在内存中，以待后续使用时快速读出。
内存在系统启动时会按照1B一个单位划分为若干个快，然后统一编号。
内存保存数据，根据数据的类型申请得到需要的空间大小
内存中的空间实际上就是占用地址线中的多少(32位系统，有32根地址线，因此地址线能表示的空间就是2^32，也就是4G)
变量就是地址的直观展示。就是内存中的一段地址，而变量值使用地址线的高低电压表示
为什么要有变量：为了方便内存上读数据和存数据。在内存上通过一个逻辑的名字铆钉了一段物理空间，读取这个逻辑名字的同时，就会把物理空间的内容读取出来

变量的分类
本地变量：用户私有变量，只有本用户可以使用，保存在家目录下的.bash_profile、.bashrc文件中
全局变量：所有用户都可以使用，保存在 /etc/profile、/etc/bashrc 文件中
用户自定义变量：用户自定义，比如脚本中的变量
Shell中的变量声明：
var_name=value
读取变量的内容 $var_name
删除变量：unset  var_name
变量的生命周期：本地变量，全局变量系统开机生成，关机销毁
用户自定义变量：相应的程序结束
Shell中的变量建议全部大写
注意点：定义全局变量的时，要在全局变量前加上 export。不加export无法对全部用户生效，该变量仍旧是一个本地变量
```
vim /etc/profile
SETVAR='want to be a global variab'  //如果想将SETVAR设置为全局变量前边要加上export
export SETVAR = 'Now is a global variable'
```


Shell中的数组：
变量和数组的区别就在于：变量一次只能存放一个值，数组一次能存放多个值
数组一次可以存放多个值，需要读取数据时只需要通过索引调用就可以方便读出
数组分为两类：一类是基本数组，一类是关联数组

数组的语法格式：
array_name=(value1   value2   value3  ......)
注意，Shell中数组元素之间没有逗号.索引依然是从0开始的
数组元素的读取：
${array_name[index]}
数组元素的赋值：
array_name[index]=value
数组元素可以通过初始化语法为其赋多个值，还可以使用数组接收命令的返回结果
arr1=(\`ls /\`)  //将ls /的返回结果赋值给arr1.可使用${arr[1]} ${arr[2]}对arr中的元素进行输出
数组的查看：  使用declare -a命令可以查看当前系统中所有被声明的数组
数组元素的访问：
1. 使用 ${array_name[@]}  可以访问数组中的所有元素，等同于echo ${array1[\*]}
2. 使用 ${array_name[@] : index [:num]}  从index指向的元素开始访问 num 个元素 ，num不指定，就是从index访问到数组结尾。
3. 使用 ${#array_name[@]} 获取数组元素个数；使用 ${!array_name[@]} 获取数组元素下标，只有下标没有值
数组的遍历：使用for循环即可
数组分两种：普通数组和关联数组。区别就在于：关联数组允许用户自定义数组的索引
如 declare -A arr=([index_name]='value'    [index_name2]=value    ......)
注意点：关联数组的声明必须使用 declare -A 进行声明
除了索引的不同，其他的关联数组和普通数组并无太大差异
