数据类型的分类有很多。依个人观点，我更愿意将数据类型分为：数值型、衍生型、聚合型、数据结构型 以及 自定义类型。
- 数值型 主要指 数字、枚举、字符、布尔型 等基础数据类型
- 衍生型 主要指的是 指针，以及C++中的 引用 和 auto类型
- 聚合型，指的是在内存中开辟一块连续空间的类型，如 数组、结构体、共用体 以及 类类型
- 数据结构型，主要指在数据结构一书中介绍的类型，如 链表、栈、队列、串、树、图 等
- 自定义类型，使用 typedef 或者 using 自己定义的数据类型。
如果读者有一定的编程基础的话会注意到，在数值型的划分上我是比较大胆的，我将 整数、小数、字符、枚举、布尔 放在了一个类型中。这样做的原因，是因为这些数据类型在内存以及使用上有着很多的相同，知一可熟悉全貌。所以对于 数值型 int 是重点，数值型之间的不同需要一定的时间分析掌握。还有一个大胆的想法就是将 数据结构 中的各种类型拿到了现在来说。因为现在很多的语言都实现了对基本数据结构的封装，使得这些基本数据结构使用起来及其简单便捷（使用者关注于库中提供的接口就可以像操作 int 一样操作各种数据结构）遂合并到数据类型。
名词解释：
- 封装，包装一下。代码堆放在一起不直观，表达的意思也不清楚。从上到下几万、几十万甚至千万行代码，不拆开估计是要把人往绝路上逼。所以封装就做一件事，包装代码，使其结构更加清晰明朗。所以任何你感觉是在包装代码的地方都可以称其为封装。比如函数，再比如面向对象中的封装思想。
- 接口，接口就是函数名，而函数是完成某一具体功能的多行代码。
# 数值型
前面我们提到说是数值型更加细腻的划分是：整数、小数、字符、枚举、布尔。对应的数据类型有：(整型)short、int、long、long long；(浮点型)float、double；(字符型)char；(枚举)enum；(布尔型)bool。
## 整型
整型是书面语，对应的口语化表达——整数。
整数我们就很好理解了呀。像 0，1，2，3，......，∞，这些都是都是整数。同样的 -1，-2，-3，...... 这些负数也都是整数吧。
对于这些整数我们使用整型对应的数据类型 short、int、long、long long 这些数据类型进行表达。
**同样是一个整数为什么会有好几种数据类型呢？？**这是因为不同的数据类型所能表达的最大值不同。就比如 short 最大只能表示到 32767(2^15^-1)。65535这个数就是short类型的上限，超过这个数，那么short无法表示。同理 int 所能表示的最大数字为 2^31^-1, 大概是20多亿的样子。
2^15^-1 以及  2^31^-1 中的 15 和 31 并非凭空出现，而是根据整型数值在内存中的存储形式得出。

### 整型数值在内存中的存储形式
我们知道计算机底层使用的是二进制数，换句话说就是，计算机只能存储 0 和 1 这两个数(这一个0或者1我们称之为1位，1位/1b 只能表示一个0或者一个1)。我们所看到的 字母、文字、图片、音视频 等等，都是通过一定的规则，对底层的 0、1 进行转换得出的。各数据类型亦不能逃脱法则而存在。
对于 short 呢，一个short要占16位（四位一组，可表示成 0000 0000 0000 0000 ）。二进制嘛，满2进1，所以
0 -- 000
1 -- 001
2 -- 010
3 -- 011
4 -- 100
5 -- 101
6 -- 110
7 -- 111
最终 我们可以 16 位最大能表示的数字为：2^16^,也就是65536 。但请不要忘记这里我们忽略了负整数，如果所有的整型都按照这样存储，负数的存储就成了一个问题。所以艺术家们想到了一个巧妙地主意，将最高位作为符号位，如果我的最高位是0，那么这个数就是个正数，如果我的最高位是1，那么这个数就是个负数。由此 short 所能表示的最大数字也就确定下来了，为：2^15^-1，所能表示的最小的数字为：-2^15^ 。（表示的正数要比负数少一位，这是因为1000 0000 0000 0000 和 1000 0000 0000 0000都是0，0既占用了一位正数，又占用了一位负数。最终的解决方法是通过原码、反码、补码的转换，将正数0仍表示0，负数的0转为-1，由此形成了整型的存储方法以及各整型的表示范围）

### 整型数字的越界处理
当我们了解了整型在内存中的存储形式之后，我们发现对于超过一个数据类型范围的数字。比如对于short来说，超过了 2^15^-1，计算机要作何处理呢。
理解这个问题并不难，一幅图就能非常清晰的说明这个问题
![整型越界问题](https://img-blog.csdnimg.cn/cf41cf4874eb46f9af34b4b9f66ed9ed.png#pic_center)
选择任意节点顺时针表示加法，逆时针表示减法。可推知当达到给定数据类型的最大值时，再加就会由该类型的最小值开始计算；当达到给定数据类型的最小值时，再减就会由该类型的最大值开始计数。

### 关于溢出的产生以及避免方法
溢出/类型越界，产生的方式无非就两种。一种是使用了小的数据类型；还有一种是计算过程中产生越界，导致结算结果出现问题。
其实随着项目规模的日益增加，刚开始适用的一个数据类型，到后期可能就不适用了。对系统来说，影响程度不一，影响小改改就好。但如果有重大影响就要考虑重构了。
计算过程中会产生越界也很容易理解。比如我有一个 int 类型的数据，它能表示到 21 亿，如果我的算式是多个数相乘，或者两个上万的数字相乘 `1000 * 100 * 100 或者 10000 * 10000` 这时候就要小心了因为一个不小心可能就溢出了。
解决计算中的溢出问题，最简单的方法就是使用 浮点型如double类型转换一下，然后再转为你想要的类型。

## 浮点数
浮点数是书面语，对应的口语化表达——小数。
浮点数对应的数据类型有两个 float 和 double。两者的区别在于表示的数据范围不同。float 使用32位用于存储一个小数，而double使用64位来表示一个小数，因此float又称单精度浮点型，double又称双进度浮点型。
对于浮点型我们要知道：
- doubel基本能表示我们所需要的所有数值
- 小数点后的位数，默认是6位。

## 字符型
我们知道计算机最底层只存放 0 和 1，所以存储数字、字符、图片这些内容就要通过一定的方式将他们转换为 0 和 1，这就是我们常说的编码。既然是编码就要有一定的规则，我们使用 ASCII 码进行字符编码的介绍。
ASCII编码，美国那边开发的用于计算机打印的字符集。共计收录128(2^7^)个字符，这128个字符包括了 数字、大写字母、小写字母、可视化字符(如{}、[]等)、不可视化字符(如 回车、删除等) 以及 空字符。完全满足美国人的使用，但根本不适用美国以外的地区，尤其是与我国文化同源的东亚地区。由此可见在技术上也不存在真正的公平正义，谁能领先一步，谁就能争取到更大的话语权。
这里有一点需要我们注意的地方：**一个字节是8位。** 能完美兼容ASCII码表。但存储ASCII只需要7位就够了，于是就将一个字节的最高位当作符号位，于是字符型和整型就有了共通性。

### 字符型和整型的辨析
字符型可视为特殊的整型，但又不完全等于整型。因为字符型有它自己的解析规则。
因为字符型是特殊的整型，所以字符型可以进行简单的计算，且越界规则同整型。
字符按照编码集来解析字符，因此你可以对照编码集将一个字符和它对应的整数相关联。
